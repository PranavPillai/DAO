pragma solidity ^0.4.0;

// Problems with this implementation to think about

contract StandardToken{
    
    function StandardToken() {
        totalSupply = 0;
    }
    
    function transfer(address _to, uint256 _value) returns (bool success) {
    //Default assumes totalSupply can't be over max (2^256 - 1).
    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
    //Replace the if with this one instead.
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    //if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      return true;
    } else { return false; }
    }
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    //same as above. Replace this line with the following if you want to protect against wrapping uints.
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      return true;
    } else { return false; }
  }
  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    return true;
  }
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  
  function mint(address _to,uint _amount) {
      totalSupply += _amount;
      balances[_to] += _amount;
  }
  
  function addEther(address _to, uint _amount) {
      etherBalance[_to] += _amount;
  }
  
  function getEther(address _address) returns (uint) {
      return etherBalance[_address];
  }
  
  mapping(address => uint256) public balances;
  mapping (address => mapping (address => uint256)) allowed;
  mapping(address => uint256) public etherBalance;
  uint256 public totalSupply;
}

contract DAO {
    
    uint totalDaoTokens;
    uint tokenCost;
    uint tokenSellLength;
    uint currentTime;
    uint totalEth;
    uint proposalID;
    uint latestProposal;
    uint cumulativeROI;
    
    StandardToken DAOToken;
    mapping (uint => Proposal) proposals;
    mapping (address => uint) etherBalance;

    modifier onlyBy(address _account) {
        if (msg.sender != _account) 
            throw;
        _;
    }
    
    modifier onlyBefore(uint duration, uint startTime) {
        if (now > startTime + duration)
            throw;
        _;
    }
    
    modifier onlyAfter(uint duration, uint startTime) {
        if (now < startTime + duration)
            throw;
        _;
    }
    
    struct Proposal {
        
        uint hash;
        address recipient;
        uint amount;
        string description;
        uint ROI;
        uint numVotes;
        uint votesFor;
        uint startTime;
        uint votingPeriod;
        uint endTime;
        mapping (address => bool) voted;
    }
    
    
    function DAO(uint _tokenCost, uint _tokenSellLength, address _token) {
        
        tokenCost = _tokenCost;
        tokenSellLength = _tokenSellLength;
        DAOToken = new StandardToken();
        currentTime = now;
        totalDaoTokens = 0;
        proposalID = 0;
        cumulativeROI = 100;
    }
    
    function invest() onlyBefore(tokenSellLength, currentTime) payable returns (bool) {
        if (msg.value < tokenCost || tokenCost == 0) throw;
        uint numTokens = msg.value/tokenCost;
        DAOToken.mint(msg.sender, numTokens);
        DAOToken.addEther(msg.sender, msg.value);
        uint change = msg.value - numTokens*tokenCost;
        if(!msg.sender.send(change)) throw;
        return true;
    }
    
    function newProposal (address _recipient, 
    uint _amount, 
    string _description, 
    uint _amountROI, 
    uint _votingPeriod) 
    returns (uint proposalID) {
        
        uint hash = proposalID;
        proposalID += 1;
        proposals[hash] = Proposal(hash, _recipient, _amount, _description, _amountROI, 0, 0, now, _votingPeriod, now+_votingPeriod);
        if(proposals[latestProposal].endTime < proposals[hash].endTime) {
            latestProposal = hash;
        }
        return hash;
    }
    
    function  vote(uint _proposalID, 
    bool _supportProposal) 
    onlyBefore(proposals[_proposalID].votingPeriod, proposals[_proposalID].startTime) public
    {
        if(proposals[_proposalID].voted[msg.sender]) throw;
        proposals[_proposalID].voted[msg.sender] == true;
        proposals[_proposalID].numVotes += DAOToken.balanceOf(msg.sender);
        if (_supportProposal) {
            proposals[_proposalID].votesFor += DAOToken.balanceOf(msg.sender);
        }
    }
    
    function transfer(address _to, uint _value) returns (bool)
    {
        if(proposals[latestProposal].voted[msg.sender]) throw;
        if(proposals[latestProposal].voted[_to]) throw;
        return DAOToken.transfer(_to, _value);
    }
    
    function approve(address _spender, uint _value) returns (bool) {
        
        if(proposals[latestProposal].voted[msg.sender]) throw;
        if(proposals[latestProposal].voted[_spender]) throw;
        return DAOToken.approve(_spender, _value);
        
    }
    
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        
        if(proposals[latestProposal].voted[_from]) throw;
        if(proposals[latestProposal].voted[_to]) throw;
        
        return DAOToken.transferFrom(_from, _to, _value);
    }
    
    function executeProposal(uint _proposalID) payable onlyAfter(proposals[_proposalID].votingPeriod, proposals[_proposalID].startTime)
    returns (bool success) {
        
        if (proposals[_proposalID].numVotes > proposals[_proposalID].votesFor*2) {
            return true;
        }
        else {
            if(!proposals[_proposalID].recipient.send(proposals[_proposalID].amount)) throw;
            delete proposals[_proposalID];
            return true;
        }
    }
    
    function payBackInvestment(uint _proposalID) payable returns (bool success) {
        if (msg.value < proposals[_proposalID].amount*proposals[_proposalID].ROI/100) throw;
        cumulativeROI += proposals[_proposalID].ROI;
        return true;
    }
    
    function withdrawEther() returns (bool) {
        
        if(proposals[latestProposal].voted[msg.sender] == true) throw;
        if(!msg.sender.send(DAOToken.getEther(msg.sender) * cumulativeROI / 100)) throw;
        
    }
    
}
