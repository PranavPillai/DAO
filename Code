pragma solidity ^0.4.0;

contract StandardToken{
    
    function StandardToken() {
        totalSupply = 0;
    }
    
    function transfer(address _to, uint256 _value) returns (bool success) {
    //Default assumes totalSupply can't be over max (2^256 - 1).
    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
    //Replace the if with this one instead.
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    //if (balances[msg.sender] >= _value && _value > 0) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      return true;
    } else { return false; }
    }
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    //same as above. Replace this line with the following if you want to protect against wrapping uints.
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      return true;
    } else { return false; }
  }
  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    return true;
  }
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  
  function mint(address _to,uint _amount) {
      totalSupply += _amount;
      balances[_to] += _amount;
  }
  
  mapping(address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
  uint256 public totalSupply;
}

contract DAO {
    
    uint totalDaoTokens;
    uint tokenCost;
    uint tokenSellLength;
    uint currentTime;
    uint totalEth;
    uint latestProposal;
    
    StandardToken DAOToken;
    
    mapping (address => uint) numDAOTokens;
    mapping (uint => Proposal) proposals;

    modifier onlyBy(address _account) {
        if (msg.sender != _account) 
            throw;
        _;
    }
    
    modifier onlyBefore(uint duration, uint startTime) {
        if (now > startTime + duration)
            throw;
        _;
    }
    
    modifier onlyAfter(uint duration, uint startTime) {
        if (now < startTime + duration)
            throw;
        _;
    }
    
    
    struct Proposal {
        
        uint hash;
        address recipient;
        uint amount;
        string description;
        uint ROI;
        uint numVotes;
        uint startTime;
        uint votingPeriod;
        mapping(address => uint) votes;
    }
    
    function DAO(uint _tokenCost, uint _tokenSellLength, address _token) {
        
        tokenCost = _tokenCost;
        tokenSellLength = _tokenSellLength;
        DAOToken = new StandardToken();
        currentTime = now;
        totalDaoTokens = 0;
        proposalID = 0;
    }
    
    function invest() onlyBefore(tokenSellLength, currentTime) payable returns (bool) {
        if (msg.value < tokenCost || tokenCost == 0) throw;
        uint numTokens = msg.value/tokenCost;
        DAOToken.mint(msg.sender, numTokens);
        uint change = msg.value - numTokens*tokenCost;
        if(!msg.sender.send(change)) throw;
        return true;
    }
    
    function newProposal (address _recipient, 
    uint _amount, 
    string _description, 
    uint _amountROI, 
    uint _votingPeriod) 
    returns (uint proposalID) {
        
        uint hash = uint(sha3(_recipient, _amount, _description, _amountROI, _votingPeriod, proposalID));
        proposalID += 1;
        proposals[hash] = Proposal(hash, _recipient, _amount, _description, _amountROI, 0, now, _votingPeriod);
        latestProposal = hash;
        return hash;
    }
    
    function vote(uint _proposalID, 
    bool _supportProposal) 
    onlyBefore(proposals[_proposalID].votingPeriod, proposals[_proposalID].startTime) 
    {
        
    }
    
    function transfer(address _to, uint _value) onlyAfter(proposals[latestProposal].votingPeriod, proposals[latestProposal].startTime)
        
    }
    
}
